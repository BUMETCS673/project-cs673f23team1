import _mergeJSXProps from 'babel-helper-vue-jsx-merge-props';
import _extends from 'babel-runtime/helpers/extends';
import shallowEqual from 'shallowequal';
import omit from 'omit.js';
import { getOptionProps, getListeners } from '../props-util';
import PropTypes from '../vue-types';
import proxyComponent from '../proxyComponent';

function getDisplayName(WrappedComponent) {
  return WrappedComponent.name || 'Component';
}

var defaultMapStateToProps = function defaultMapStateToProps() {
  return {};
};
export default function connect(mapStateToProps, injectExtraPropsKey) {
  var shouldSubscribe = !!mapStateToProps;
  var finalMapStateToProps = mapStateToProps || defaultMapStateToProps;
  return function wrapWithConnect(WrappedComponent) {
    var tempProps = omit(WrappedComponent.props || {}, ['store']);
    var props = {
      __propsSymbol__: PropTypes.any
    };
    Object.keys(tempProps).forEach(function (k) {
      props[k] = _extends({}, tempProps[k], { required: false });
    });
    var Connect = {
      name: 'Connect_' + getDisplayName(WrappedComponent),
      props: props,
      inject: _extends({
        storeContext: { 'default': function _default() {
            return {};
          } }
      }, injectExtraPropsKey ? {
        injectExtraContext: {
          from: injectExtraPropsKey,
          'default': function _default() {
            return {};
          }
        }
      } : {}),
      computed: {
        injectExtraProps: function injectExtraProps() {
          return this.injectExtraContext ? this.injectExtraContext.$attrs : {};
        },
        injectExtraListeners: function injectExtraListeners() {
          return this.injectExtraContext ? this.injectExtraContext.$listeners : {};
        }
      },
      data: function data() {
        this.store = this.storeContext.store;
        this.preProps = _extends({}, omit(getOptionProps(this), ['__propsSymbol__']), this.injectExtraProps);
        return {
          subscribed: finalMapStateToProps(this.store.getState(), _extends({}, this.$props, this.injectExtraProps))
        };
      },

      watch: {
        __propsSymbol__: function __propsSymbol__() {
          if (mapStateToProps && mapStateToProps.length === 2) {
            this.subscribed = finalMapStateToProps(this.store.getState(), _extends({}, this.$props, this.injectExtraProps));
          }
        }
      },
      mounted: function mounted() {
        this.trySubscribe();
      },
      beforeDestroy: function beforeDestroy() {
        this.tryUnsubscribe();
      },

      methods: {
        handleChange: function handleChange() {
          if (!this.unsubscribe) {
            return;
          }
          var props = _extends({}, omit(getOptionProps(this), ['__propsSymbol__']), this.injectExtraProps);
          var nextSubscribed = finalMapStateToProps(this.store.getState(), props);
          if (!shallowEqual(this.preProps, props) || !shallowEqual(this.subscribed, nextSubscribed)) {
            this.subscribed = nextSubscribed;
          }
        },
        trySubscribe: function trySubscribe() {
          if (shouldSubscribe) {
            this.unsubscribe = this.store.subscribe(this.handleChange);
            this.handleChange();
          }
        },
        tryUnsubscribe: function tryUnsubscribe() {
          if (this.unsubscribe) {
            this.unsubscribe();
            this.unsubscribe = null;
          }
        },
        getWrappedInstance: function getWrappedInstance() {
          return this.$refs.wrappedInstance;
        }
      },
      render: function render() {
        var h = arguments[0];
        var _$slots = this.$slots,
            $slots = _$slots === undefined ? {} : _$slots,
            $scopedSlots = this.$scopedSlots,
            subscribed = this.subscribed,
            store = this.store;

        var props = _extends({}, getOptionProps(this), this.injectExtraProps);
        this.preProps = _extends({}, omit(props, ['__propsSymbol__']));
        var wrapProps = {
          props: _extends({}, props, subscribed, {
            store: store
          }),
          on: _extends({}, getListeners(this), this.injectExtraListeners),
          scopedSlots: $scopedSlots
        };
        return h(
          WrappedComponent,
          _mergeJSXProps([wrapProps, { ref: 'wrappedInstance' }]),
          [Object.keys($slots).map(function (name) {
            return h(
              'template',
              { slot: name },
              [$slots[name]]
            );
          })]
        );
      }
    };
    return proxyComponent(Connect);
  };
}